
#!/bin/bash 


_version='1.02'
	
_plan_set=0
_no_plan=0
_skip_all=0
_test_died=0
_expected_tests=0 
_executed_tests=0 
_failed_tests=0
TODO=


usage(){
	cat <<'USAGE'
tap-functions: A TAP-producing BASH library

PLAN:
  plan_no_plan
  plan_skip_all [REASON]
  plan_tests NB_TESTS

TEST:
  ok RESULT [NAME]
  okx COMMAND
  is RESULT EXPECTED [NAME]
  isnt RESULT EXPECTED [NAME]
  like RESULT PATTERN [NAME]
  unlike RESULT PATTERN [NAME]
  pass [NAME]
  fail [NAME]

SKIP:
  skip [CONDITION] [REASON] [NB_TESTS=1]

  skip $feature_not_present "feature not present" 2 || {
      is $a "a"
      is $b "b"
  }

TODO:
  Specify TODO mode by setting $TODO:
    TODO="not implemented yet"
    ok $result "some not implemented test"
    unset TODO

OTHER:
  diag MSG

EXAMPLE:
  #!/bin/bash

  . tap-functions

  plan_tests 7

  me=$USER
  is $USER $me "I am myself"
  like $HOME $me "My home is mine"
  like "`id`" $me "My id matches myself"

  /bin/ls $HOME 1>&2
  ok $? "/bin/ls $HOME"
  # Same thing using okx shortcut
  okx /bin/ls $HOME

  [[ "`id -u`" != "0" ]]
  i_am_not_root=$?
  skip $i_am_not_root "Must be root" || {
    okx ls /root
  }

  TODO="figure out how to become root..."
  okx [ "$HOME" == "/root" ]
  unset TODO
USAGE
	exit
}

opt=
set_u=
while getopts ":sx" opt ; do
	case $_opt in
        u) set_u=1 ;;
        *) usage ;;
    esac
done
shift $(( OPTIND - 1 ))
# Don't allow uninitialized variables if requested
[[ -n "$set_u" ]] && set -u
unset opt set_u

# Used to call _cleanup on shell exit
trap _exit EXIT



plan_no_plan(){
	(( _plan_set != 0 )) && "You tried to plan twice!"

	_plan_set=1
	_no_plan=1

	return 0
}


plan_skip_all(){
	local reason=${1:-''}

	(( _plan_set != 0 )) && _die "You tried to plan twice!"

	_print_plan 0 "Skip $reason"

	_skip_all=1
	_plan_set=1
	_exit 0

	return 0
}


plan_tests(){
	local tests=${1:?}

	(( _plan_set != 0 )) && _die "You tried to plan twice!"
	(( tests == 0 )) && _die "You said to run 0 tests!  You've got to run something."

	_print_plan $tests
	_expected_tests=$tests
	_plan_set=1

	return $tests
}


_print_plan(){
	local tests=${1:?}
	local directive=${2:-''}

	echo -n "1..$tests"
	[[ -n "$directive" ]] && echo -n " # $directive"
	echo
}


pass(){
	local name=$1
	ok 0 "$name"
}


fail(){
	local name=$1
	ok 1 "$name"
}


# This is the workhorse method that actually
# prints the tests result.
ok(){
	local result=${1:?}
	local name=${2:-''}

	(( _plan_set == 0 )) && _die "You tried to run a test without a plan!  Gotta have a plan."

	_executed_tests=$(( $_executed_tests + 1 ))

	if [[ -n "$name" ]] ; then
		if _matches "$name" "^[0-9]+$" ; then
			diag "    You named your test '$name'.  You shouldn't use numbers for your test names."
			diag "    Very confusing."
		fi
	fi

	if (( result != 0 )) ; then
		echo -n "not "
		_failed_tests=$(( _failed_tests + 1 ))
	fi
	echo -n "ok $_executed_tests"

	if [[ -n "$name" ]] ; then
		local ename=${name//\#/\\#}
		echo -n " - $ename"
	fi
